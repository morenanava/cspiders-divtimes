#-------------------#
# CLEAN ENVIRONMENT #
#-------------------#
rm( list = ls( ) )
#-----------------------------------------------#
# LOAD PACKAGES, FUNCTIONS, AND SET ENVIRONMENT #
#-----------------------------------------------#
# This package lets you find automatically the path to a specific location
# in your file structure
# If you have not installed this package, you will need to install it.
# You can uncomment the following line to do this:
#install.packages( "rstudioapi" )
library( rstudioapi )
# Get the path to current open R script and find main dir
path_to_file <- getActiveDocumentContext()$path
wd <- paste( dirname( path_to_file ), "/", sep = "" )
setwd( wd )
# This script and the `Functions.R` script are saved under
# a directory called `scripts`. We will remove this part from
# the path to find our home directory
home_dir <- gsub( pattern = "scripts/", replacement = "", x = wd )
# Load main script with all functions required below
source( file = "../../../src/Functions.R" )
# 1. Label the file with calibrations. If you have tested different calibrations
# and have more than one file with the corresponding calibrations, give as
# many labels as files you have.
dat <- c( "noeurycyde", "noUCEs", "supaln" )
# 2. Number of divergence times that have been estimated. One trick to find
# this out quickly is to subtract 1 to the number of species. In this case,
# there are 218 taxa (218), so the number of internal nodes
# is `n_taxa=218-1=217`.
# Another way to verify this is by opening the `mcmc.txt` file and check the
# header. The first element after `Gen` will have the format of `t_nX`, where
# X will be an integer (i.e., 219). Subtract two to this number
# (i.e., 701-2=217) and this will be your number of divergence times that are
# parameters of the MCMC. Please modify the number below so it fits to the
# dataset you are using.
num_divt <- 217
# or `sum_prior_QC$<name_dataset>$total_samples`
# CLK: The number of lines is 120006 (all 3); you need to specify one less
# GBM: The number of lines are 316353, 320016, and 313827; you need to specify
#      one less
# ILN: The number of lines is 320016, 315033, 320016 and so you need to specify
#      one less
#
# NOTE: If you had more than one dataset, you would add another vector of three
# values with the samples for CLK, GBM, and ILN to create `def_samples`
# E.g. two datasts: c( c( 120005, 120005, 120005), c( 120005, 120005, 120005) )
def_samples <- c( c( 120005, 316352, 320015 ),  #noeruycyde
c( 120005, 320015, 315032 ),  #noUCEs
c( 120005, 313826, 320015 ) ) #supaln
# 4. Quantile percentage that you want to set By default, the variable below is
# set to 0.975 so the 97.5% and 2.5% quantiles (i.e., 95%CI). If you want to
# change this, however, just modify the value.
perc <- 0.975
# would be set to `delcol_post <- 2`. Please modify the value/s below
# (depending on having one or more datasets) according to the `mcmc.txt` file
# generated when sampling from the posterior (`delcol_obj`). When running
# from the prior and `clock = 1`, you will only see `mu*` columns but, if you
# ran it with options `clock = 2` or `clock = 3`, you shall also see `sigma2*`
# columns.
##> NOTE: If you ran `MCMCtree` with `clock = 2` or `clock = 3` when
##> sampling from the prior, you will also need to count the `sigma2*`
##> columns! We ran `clock = 1` so that the analyses ran quicker, and thus
##> we only have `mu*` columns.
delcol_obj <- rep( c( 1, 2, 2 ), 3 ) # prior (1), posterior (2), posterior (2)
# 6. Path to the directory where the concatenated `mcmc.txt` file has been
# generated. Note that, if you have run more than one chain in `MCMCtree` for
# each hypothesis tested, you are expected to have generated a concatenated
# `mcmc.txt` file with the bash script `Combine_MCMC_prior.sh` or any similar
# approaches.
num_dirs  <- length( dat )*3 # Keep "3" if three models tested: CLK, GBM, ILN
paths_dat <- vector( mode = "character", length = num_dirs )
start <- stop <- 0
for( i in 1:length( dat ) ){
start <- stop + 1
stop  <- stop + 3
#cat( "start: ", start, "\nstop:", stop, "\n" )
paths_dat[start:stop] <- c( paste( home_dir,
"sum_analyses/00_prior/mcmc_files_",
dat[i], "_CLK", sep = "" ),
paste( home_dir,
"sum_analyses/01_posterior/mcmc_files_",
dat[i], "_GBM", sep = "" ),
paste( home_dir,
"sum_analyses/01_posterior/mcmc_files_",
dat[i], "_ILN", sep = "" ) )
}
#  The format accepted has three parameters: xi (location, mean root age),
#  omega (scale), alpha (shape). Accepted format:
#  >> SN(5.8300,0.0590,0.1120)
#
#
# The next command executes the `read_calib_f` in-house function, which reads
# your input files (semicolon-separated files). The path to this directory is
# what the argument `main_dir` needs. The argument `f_names` requires the name
# of the file/s that you have used. Argument `dat` requires the same global
# object that you have created at the beginning of the script.
dat_ff <- list.files( path = "../calib_files", pattern = "csv",
full.names = FALSE )
#  The format accepted has three parameters: xi (location, mean root age),
#  omega (scale), alpha (shape). Accepted format:
#  >> SN(5.8300,0.0590,0.1120)
#
#
# The next command executes the `read_calib_f` in-house function, which reads
# your input files (semicolon-separated files). The path to this directory is
# what the argument `main_dir` needs. The argument `f_names` requires the name
# of the file/s that you have used. Argument `dat` requires the same global
# object that you have created at the beginning of the script.
dat_ff <- list.files( path = "../calib_files", pattern = "csv",
full.names = FALSE )
##> CHECK
# If there was a `margVScalib` generated, use it! If not, this means
# that your `csv` file has already the required format to proceed
is_margcsv <- grep( pattern = "margVScalib", x = dat_ff )
if( length( is_margcsv ) > 0 ){
dat_ff <- dat_ff[is_margcsv]
}
##> END CHECK
calib_nodes <- read_calib_f( main_dir = paste( home_dir, "calib_files/",
sep = "" ),
f_names = dat_ff,
dat = dat, head_avail = TRUE )
dat_ff
##> END CHECK
calib_nodes <- read_calib_f( main_dir = paste( home_dir, "calib_files/",
sep = "" ),
f_names = dat_ff,
dat = dat, head_avail = TRUE )
#-----------#
# LOAD DATA #
#-----------#
# Load mcmc files for all datasets
mcmc_obj <- vector( "list", num_dirs )
count <- 0
for( i in dat ){
count <- count + 1
names( mcmc_obj )[count] <- paste( "CLK_", i, sep = "" )
count <- count + 1
names( mcmc_obj )[count] <- paste( "GBM_", i, sep = "" )
count <- count + 1
names( mcmc_obj )[count] <- paste( "ILN_", i, sep = "" )
}
prior <- rep( c( TRUE, FALSE, FALSE ), length( dat ) )
count <- 0
for( i in c( paths_dat ) ){
count <- count + 1
cat( "[[ Parsing file for dataset", names( mcmc_obj )[count], " ]]\n" )
mcmc_obj[[count]] <- load_dat( mcmc = paste( i, "/mcmc.txt", sep = "" ),
delcol = delcol_obj[count], perc = perc,
def_samples = def_samples[count],
prior = prior[count] )
}
#---------------------------#
# PLOTS: prior VS posterior #
#---------------------------#
# Plot calibrated nodes
count_mcmc <- 0
for( k in 1:length(dat) ){
name_labs   <- calib_nodes[[ k ]][,2] ## one set of cals per dataset
labs_in_csv <- paste( "t_n", calib_nodes[[ k ]][,2], sep = "" )
# Extract CLK, GBM, and ILN from `mcmc_obj` for that specific dataset
cat( "[[ DATASET ", dat[k], "]]\n" )
count_mcmc  <- count_mcmc + 1
cat( " ---> Extracting data ", names(mcmc_obj)[count_mcmc], "\n" )
mcmc_CLK    <- mcmc_obj[[ count_mcmc ]]
count_mcmc  <- count_mcmc + 1
cat( " ---> Extracting data ", names(mcmc_obj)[count_mcmc], "\n" )
mcmc_GBM    <- mcmc_obj[[ count_mcmc ]]
count_mcmc  <- count_mcmc + 1
cat( " ---> Extracting data ", names(mcmc_obj)[count_mcmc], "\n" )
mcmc_ILN    <- mcmc_obj[[ count_mcmc ]]
# Start plotting!
for( i in 1:length(labs_in_csv) ){
pdf( file = paste( home_dir, "plots/priorVSpost_", dat[k], "_",
calib_nodes[[ k ]][i,1], "_", name_labs[i], "_plot.pdf",
sep = "" ),
paper = "a4r", width = 0, height = 0 )
# Get calibration densities in correct formatting (4 nums)
is_B    <- grep( x = calib_nodes[[ k ]][i,3], pattern = "B\\(" )
is_U    <- grep( x = calib_nodes[[ k ]][i,3], pattern = "U\\(" )
is_L    <- grep( x = calib_nodes[[ k ]][i,3], pattern = "L\\(" )
is_flag <- grep( x = calib_nodes[[ k ]][i,3], pattern = "flag" )
if( length( is_B ) == 1 && length( is_flag ) == 0 ){
# 4 numbers
tmp_allcal <- as.numeric( stringr::str_split( string = gsub( pattern = "B\\(|\\)",
replacement = "",
x = calib_nodes[[ k ]][i,3] ),
pattern = "," )[[1]] )
}
if( length( is_U ) == 1 && length( is_flag ) == 0 ){
# 2 numbers
tmp_allcal <- as.numeric( stringr::str_split( string = gsub( pattern = "U\\(|\\)",
replacement = "",
x = calib_nodes[[ k ]][i,3] ),
pattern = "," )[[1]] )
}
if( length( is_L ) == 1 && length( is_flag ) == 0 ){
# 2 numbers
tmp_allcal <- as.numeric( stringr::str_split( string = gsub( pattern = "L\\(|\\)",
replacement = "",
x = calib_nodes[[ k ]][i,3] ),
pattern = "," )[[1]] )
}
if( length( is_flag ) == 1 ){
tmp_allcal <- ""
}
# Get max/min x and y
##> NOTE: Only the first number is used, because the other number/s in
##> `dup_dat[[i]` have the same fossil info!
tn_matrix <- which( colnames(mcmc_GBM$divt) %in% labs_in_csv[i] )
max_y     <- max( c( max( density( mcmc_GBM$divt[[ tn_matrix[1] ]], adj = 1 )$y ),
max( density( mcmc_ILN$divt[[ tn_matrix[1] ]], adj = 1 )$y ),
max( density( mcmc_CLK$divt[[ tn_matrix[1] ]], adj = 1 )$y ) ) )
if( length( is_B ) == 1 && length( is_flag ) == 0 ){
max_x <- max( c( max( density( mcmc_GBM$divt[[ tn_matrix[1] ]], adj = 1 )$x ),
max( density( mcmc_ILN$divt[[ tn_matrix[1] ]], adj = 1 )$x ),
max( density( mcmc_CLK$divt[[ tn_matrix[1] ]], adj = 1 )$x ),
tmp_allcal[2]) )
min_x <- min( c( min( density( mcmc_GBM$divt[[ tn_matrix[1] ]], adj = 1 )$x ),
min( density( mcmc_ILN$divt[[ tn_matrix[1] ]], adj = 1 )$x ),
min( density( mcmc_CLK$divt[[ tn_matrix[1] ]], adj = 1 )$x ),
tmp_allcal[1] ) )
}
if( length( is_U ) == 1 && length( is_flag ) == 0 ){
max_x <- max( c( max( density( mcmc_GBM$divt[[ tn_matrix[1] ]], adj = 1 )$x ),
max( density( mcmc_ILN$divt[[ tn_matrix[1] ]], adj = 1 )$x ),
max( density( mcmc_CLK$divt[[ tn_matrix[1] ]], adj = 1 )$x ),
c( tmp_allcal[1] + 1 ) ) )
min_x <- min( c( min( density( mcmc_GBM$divt[[ tn_matrix[1] ]], adj = 1 )$x ),
min( density( mcmc_ILN$divt[[ tn_matrix[1] ]], adj = 1 )$x ),
min( density( mcmc_CLK$divt[[ tn_matrix[1] ]], adj = 1 )$x ) ) )
}
if( length( is_L ) == 1 && length( is_flag ) == 0 ){
max_x <- max( c( max( density( mcmc_GBM$divt[[ tn_matrix[1] ]], adj = 1 )$x ),
max( density( mcmc_ILN$divt[[ tn_matrix[1] ]], adj = 1 )$x ),
max( density( mcmc_CLK$divt[[ tn_matrix[1] ]], adj = 1 )$x ),
c( tmp_allcal[1]) + 2 ) )
min_x <- min( c( min( density( mcmc_GBM$divt[[ tn_matrix[1] ]], adj = 1 )$x ),
min( density( mcmc_ILN$divt[[ tn_matrix[1] ]], adj = 1 )$x ),
min( density( mcmc_CLK$divt[[ tn_matrix[1] ]], adj = 1 )$x ),
tmp_allcal[1] ) )
}
if( length( is_flag ) == 1 ){
max_x <- max( c( max( density( mcmc_GBM$divt[[ tn_matrix[1] ]], adj = 1 )$x ),
max( density( mcmc_ILN$divt[[ tn_matrix[1] ]], adj = 1 )$x ),
max( density( mcmc_CLK$divt[[ tn_matrix[1] ]], adj = 1 )$x ) ) )
min_x <- min( c( min( density( mcmc_GBM$divt[[ tn_matrix[1] ]], adj = 1 )$x ),
min( density( mcmc_ILN$divt[[ tn_matrix[1] ]], adj = 1 )$x ),
min( density( mcmc_CLK$divt[[ tn_matrix[1] ]], adj = 1 )$x ) ) )
}
# Get name of calibration, which corresponds to the first calibration
# in the list
tmp_name_calib <- calib_nodes[[ k ]][i,1]
# Start plotting densities for each calibrated
# node -- easy for comparisons!
# Get temporary matching column in `mcmc_obj` to `j`
plot( density( unlist( mcmc_GBM$divt[ tn_matrix ] ), adj = 1 ),
main = paste( "Comparing densities",
labs_in_csv[i], " | ", tmp_name_calib, sep = "" ),
col = "blue", ylim = c(0,max_y), xlim = c(min_x, max_x) )
lines( density( unlist( mcmc_CLK$divt[ tn_matrix ] ), adj = 1 ),
col = "brown" )
lines( density( unlist( mcmc_ILN$divt[ tn_matrix ] ), adj = 1 ),
col = "darkolivegreen3" )
if( length( is_B ) == 1 && length( is_flag ) == 0 ){
curve( mcmc3r::dB( x, tL = tmp_allcal[1], tU = tmp_allcal[2],
pL = tmp_allcal[3], pU = tmp_allcal[4] ),
from = tmp_allcal[1]-0.5, to = tmp_allcal[2]+0.5,
n = 1e5, add = TRUE, col = "black" )
}
if( length( is_U ) == 1 && length( is_flag ) == 0 ){
curve( mcmc3r::dU( x, tU = tmp_allcal[1], pU = tmp_allcal[2] ),
from = min_x, to = tmp_allcal[1]+1,
n = 1e5, add = TRUE, col = "black" )
}
if( length( is_L ) == 1 && length( is_flag ) == 0 ){
curve( mcmc3r::dL( x, tL = tmp_allcal[1], pL = tmp_allcal[2] ),
from = tmp_allcal[1]-1, to = max_x,
n = 1e5, add = TRUE, col = "black" )
}
legend( "topleft", legend = c( paste( "Calibation density\n",
calib_nodes[[ k ]][i,3], "\n",
sep = "" ),
"Marginal density",
"Post-GBM", "Post-ILN"),
lwd = 1, bty = "n", cex = 1.8,
col = c( "black", "brown", "blue", "darkolivegreen3" ) )
cols_vec <- c( "blue", "red", "purple", "darkgreen", "brown" )
# Close pdf
dev.off()
}
}
